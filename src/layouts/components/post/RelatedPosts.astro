---
import type { CollectionEntry, InferEntrySchema } from 'astro:content';
import { PostUtils, CollectionUtils } from "@utils/collectionUtils";
import { shuffleArray } from "@utils/arrayUtils";
import PostCard from "./PostCard.astro";

interface Props {
  currentSlug: string;
  currentPostData: InferEntrySchema<"posts">;
  limit?: number;
}

const { currentSlug, currentPostData, limit = 3 } = Astro.props;

const otherPosts = await new CollectionUtils("posts")
  .filter(PostUtils.filterNotDraft)
  .filter(PostUtils.filterNotIdEq(currentSlug))
  .all();

// Function to get related posts
function getRelatedPosts(
  currentPostData: InferEntrySchema<"posts">, otherPosts: CollectionEntry<"posts">[], limit: number
): CollectionEntry<"posts">[] {
  // Get posts with matching tags
  const postsByTags = otherPosts.filter(otPost => {
    const postTags = otPost.data.tags || [];
    const currentTags = currentPostData.tags || [];
    return currentTags.some((tag: string) => postTags.includes(tag));
  });

  // If we have enough posts with matching tags, return them
  if (postsByTags.length >= limit) {
    // Shuffle the array to get random posts with matching tags
    return shuffleArray(postsByTags).slice(0, limit);
  }

  // If we don't have enough posts with matching tags, get posts with matching categories
  const postsByCategories = otherPosts.filter(otPost => {
    const postCategories = otPost.data.categories || [];
    const currentCategories = currentPostData.categories || [];
    return currentCategories.some((category: string) => postCategories.includes(category));
  });

  // Combine unique posts from tags and categories
  const combinedPosts = [...postsByTags];
  
  // Add posts from categories that aren't already included
  postsByCategories.forEach(post => {
    if (!combinedPosts.some(p => p.id === post.id)) {
      combinedPosts.push(post);
    }
  });

  // If we have enough combined posts, return them
  if (combinedPosts.length >= limit) {
    return shuffleArray(combinedPosts).slice(0, limit);
  }

  // If we still don't have enough posts, add random posts
  const remainingPosts = otherPosts.filter(otPost =>
    !combinedPosts.some((p: CollectionEntry<"posts">) => p.id === otPost.id)
  );
  
  const result = [...combinedPosts, ...shuffleArray(remainingPosts)];
  return result.slice(0, limit);
}

const relatedPosts = getRelatedPosts(currentPostData, otherPosts, limit);
---

<section class="mt-12 pt-8 border-t border-gray-200 dark:border-gray-700">
  <h2 class="text-2xl font-bold text-gray-900 dark:text-white mb-6">相关文章</h2>
  
  <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
    {
      relatedPosts.map(
        (post) => {
          return <PostCard post={post} />;
        }
      )
    }
  </div>
</section>
